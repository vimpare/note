```
第一部分　基础知识17
第1章19
1.1 动态类型语言和鸭子类型20
1.2 多态25
1.3 封装39
1.4 原型模式和基于原型继承的JavaScript对象系统44
第2章62
2.1 this63
2.2 call和apply71
第3章82
3.1 闭包83
3.2 高阶函数99
3.3 小结125
第二部分　设计模式126
第4章128
4.1 实现单例模式129
4.2 透明的单例模式132
4.3 用代理实现单例模式135
4.4 JavaScript中的单例模式137
4.5 惰性单例141
4.6 通用的惰性单例146
4.7 小结151
第5章152
5.1 使用策略模式计算奖金154
5.2 JavaScript版本的策略模式161
5.3 多态在策略模式中的体现163
5.4 使用策略模式实现缓动动画164
5.5 更广义的“算法”171
5.6 表单校验172
5.7 策略模式的优缺点184
5.8 一等函数对象与策略模式186
5.9 小结188
第6章189
6.1 第一个例子——小明追MM的故事191
6.2 保护代理和虚拟代理196
6.3 虚拟代理实现图片预加载198
6.4 代理的意义201
6.5 代理和本体接口的一致性204
6.6 虚拟代理合并HTTP请求206
6.7 虚拟代理在惰性加载中的应用210
6.8 缓存代理216
6.9 用高阶函数动态创建代理219
6.10 其他代理模式221
6.11 小结222
第7章223
7.1 jQuery中的迭代器224
7.2 实现自己的迭代器225
7.3 内部迭代器和外部迭代器226
7.4 迭代类数组对象和字面量对象230
7.5 倒序迭代器232
7.6 中止迭代器233
7.7 迭代器模式的应用举例234
7.8 小结239
第8章240
8.1 现实中的发布－订阅模式241
8.2 发布－订阅模式的作用242
8.3 DOM事件244
8.4 自定义事件246
8.5 发布－订阅模式的通用实现250
8.6 取消订阅的事件253
8.7 真实的例子——网站登录255
8.8 全局的发布－订阅对象259
8.9 模块间通信263
8.10 必须先订阅再发布吗265
8.11 全局事件的命名冲突267
8.12 JavaScript实现发布－订阅模式的便利性274
8.13 小结275
第9章276
9.1 命令模式的用途278
9.2 命令模式的例子——菜单程序279
9.3 JavaScript中的命令模式283
9.4 撤销命令287
9.5 撤消和重做292
9.6 命令队列296
9.7 宏命令298
9.8 智能命令与傻瓜命令301
9.9 小结303
第10章304
10.1 回顾宏命令306
10.2 组合模式的用途309
10.3 请求在树中传递的过程311
10.4 更强大的宏命令313
10.5 抽象类在组合模式中的作用318
10.6 透明性带来的安全问题321
10.7 组合模式的例子——扫描文件夹323
10.8 一些值得注意的地方327
10.9 引用父对象329
10.10 何时使用组合模式333
10.11 小结334
第11章335
11.1 模板方法模式的定义和组成336
11.2 第一个例子——Coffee or Tea337
11.3 抽象类345
11.4 模板方法模式的使用场景353
11.5 钩子方法355
11.6 好莱坞原则359
11.7 真的需要“继承”吗361
11.8 小结364
第12章365
12.1 初识享元模式366
12.2 内部状态与外部状态369
12.3 享元模式的通用结构371
12.4 文件上传的例子372
12.5 享元模式的适用性383
12.6 再谈内部状态和外部状态384
12.7 对象池388
12.8 小结395
第13章396
13.1 现实中的职责链模式397
13.2 实际开发中的职责链模式399
13.3 用职责链模式重构代码402
13.4 灵活可拆分的职责链节点405
13.5 异步的职责链409
13.6 职责链模式的优缺点411
13.7 用AOP实现职责链414
13.8 用职责链模式获取文件上传对象416
13.9 小结418
第14章419
14.1 现实中的中介者422
14.2 中介者模式的例子——泡泡堂游戏424
14.3 中介者模式的例子——购买商品439
14.4 小结455
第15章457
15.1 模拟传统面向对象语言的装饰者模式459
15.2 装饰者也是包装器462
15.3 回到JavaScript的装饰者463
15.4 装饰函数465
15.5 用AOP装饰函数469
15.6 AOP的应用实例473
15.7 装饰者模式和代理模式484
15.8 小结486
第16章487
16.1 初识状态模式488
16.2 状态模式的定义498
16.3 状态模式的通用结构499
16.4 缺少抽象类的变通方式501
16.5 另一个状态模式示例——文件上传503
16.6 状态模式的优缺点520
16.7 状态模式中的性能优化点521
16.8 状态模式和策略模式的关系522
16.9 JavaScript版本的状态机523
16.10 表驱动的有限状态机527
16.11 实际项目中的其他状态机529
16.12 小结531
第17章532
17.1 现实中的适配器533
17.2 适配器模式的应用536
17.3 小结541
第三部分　设计原则和编程技巧542
第18章544
18.1 设计模式中的SRP原则545
18.2 何时应该分离职责552
18.3 违反SRP原则553
18.4 SRP原则的优缺点554
第19章555
19.1 减少对象之间的联系557
19.2 设计模式中的最少知识原则558
19.3 封装在最少知识原则中的体现563
第20章565
20.1 扩展window.onload函数566
20.2 开放和封闭568
20.3 用对象的多态性消除条件分支570
20.4 找出变化的地方573
20.5 设计模式中的开放－封闭原则577
20.6 开放－封闭原则的相对性580
20.7 接受第一次愚弄582
第21章583
21.1 回到Java的抽象类584
21.2 interface590
21.3 JavaScript语言是否需要抽象类和interface593
21.4 用鸭子类型进行接口检查596
21.5 用TypeScript编写基于interface的命令模式598
第22章605
22.1 提炼函数606
22.2 合并重复的条件片段608
22.3 把条件分支语句提炼成函数610
22.4 合理使用循环612
22.5 提前让函数退出代替嵌套条件分支614
22.6 传递对象参数代替过长的参数列表616
22.7 尽量减少参数数量618
22.8 少用三目运算符619
22.9 合理使用链式调用621
22.10 分解大型类623
22.11 用return退出多重循环626
```
